%------------------------------------------------------------------------------
%	SECTION
%------------------------------------------------------------------------------
\section{Contexto y justificación}
\label{sec:contextoYJustificacion}

En la actualidad existe una enorme variedad de plataformas de sistemas embebidos en el mercado, y si bien todas cuentan con dispositivos programables con características similares y periféricos compatibles, se observa que a la hora de programarlas todas son distintas. En consecuencia, el profesional desarrollador de sistemas embebidos debe invertir mucho tiempo en aprender a programar cada nueva plataforma.

Estas diferencias se deben a que los fabricantes de los dispositivos y empresas asociadas poseen sus respectivas arquitecturas de hardware (tanto en núcleos de procesamiento, como en periféricos). Cada periférico exhibe externamente la funcionalidad esperada, pero su configuración y uso es diferente. Si bien esto da a los fabricantes la posibilidad de diferenciarse frente a la competencia y a los desarrolladores elegir el dispositivo programable que más se adecúe a un proyecto, también causa que el programador deba conocer en detalle la arquitectura en particular del dispositivo a la hora de utilizarlo.

Además, estas empresas en su mayoría se limitan a ofrecer información de bajo nivel para programar el hardware directamente (escribiendo registros), o bien, mediante sus propias bibliotecas escritas generalmente en lenguaje C, que están diseñadas con una gran dependencia de la arquitectura de hardware subyacente, es decir, carecen de abstracción del hardware.

Por otro lado, se están portando cada vez más lenguajes de programación a las plataformas de sistemas embebidos, que antes se reservaban para las computadoras de propósito general. Esto se debe a que las nuevas plataformas poseen cada vez más poder de procesamiento y memoria, a causa de la complejidad creciente de las aplicaciones deseadas. En consecuencia se utilizan lenguajes de programación más modernos, en parte por su mayor capacidad de abstracción, y en parte para estandarizar el lenguaje de programación de una aplicación en la que intervienen sistemas embebidos y computadoras de propósito general, siendo un ejemplo típico una aplicación de IoT\footnote{Del inglés \emph{Internet of Things}, es decir, Internet de las cosas, donde intervienen en una aplicación sistemas embebidos distribuidos, infraestructura de red y servidores.}.

Existen múltiples desarrollos de bibliotecas que logran una abstracción de hardware aceptable. Sin embargo, ninguna de estas se ha adoptado como estándar de facto en la industria y el alcance de las mismas se limita a cubrir plataformas de cierto ecosistema en el marco de una empresa o comunidad y soportan un único lenguaje de programación (en general C o C++).

Este trabajo final intenta contribuir a la resolución de esta problemática mediante la sistematización de la implementación de bibliotecas para sistemas embebidos. Para ello se presenta el diseño de una biblioteca para la programación de sistemas embebidos modelada independientemente del lenguaje de programación y arquitectura del hardware. Asimismo se realizaron herramientas de código abierto para desarrolladores que automatizan gran parte de la implemetación de la biblioteca en una nueva plataforma en base a una descripción de la misma, así como la definición de nuevos módulos de bibliotecas. De esta manera se facilita la futura ampliación de la biblioteca y su implementación en diferentes plataformas de hardware.		

Utilizando estas herramientas se realizó una implementación de referencia en lenguaje C para las plataformas del Proyecto CIAA\footnote{Siglas de Computadora Industrial Abierta Argentina.} []. Para su validación, se realizó un banco de pruebas de hardware, junto a la utilización de testeo unitario e integración continua.
