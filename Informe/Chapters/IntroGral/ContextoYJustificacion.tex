%------------------------------------------------------------------------------
%	SECTION
%------------------------------------------------------------------------------
\section{Contexto y justificación}
\label{sec:contextoYJustificacion}

\emph{La idea de esta sección es presentar el tema de modo que cualquier persona que no conoce el tema pueda entender de qué se trata y por qué es importante realizar este trabajo y cuál es su impacto.}

En la actualidad existe una enorme variedad plataformas de sistemas embebidos en el mercado, y si bien todas cuentan con dispositivos programables con características similares y periféricos compatibles, se observa que a la hora de programarlos son distintos. En consecuencia, el profesional que se dedica a la programación de sistemas embebidos debe invertir mucho tiempo en aprender a programar cada nueva plataforma.

Estas diferencias se deben a que los fabricantes de los dispositivos programables y empresas asociadas poseen sus respectivas arquitecturas de hardware (tanto en núcleos de procesamiento, como periféricos). Cada periférico exhibe externamente la funcionalidad esperada, pero su configuración y uso es diferente. Si bien permite elegir el dispositivo programable que más se adecúe a un proyecto utilizando múltiples criterios y da a los fabricantes la posibilidad de diferenciarse frente a la competencia, causa que el programador deba conocer en detalle la arquitectura en particular del dispositivo a la hora de utilizarlo.

Además, estas empresas en su mayoría se limitan a ofrecer información de bajo nivel para programar el hardware directamente (escribiendo registros), o bien, sus propias bibliotecas escritas en lenguaje C, que están diseñadas con una gran dependencia de la arquitectura de hardware subyacente, es decir, carecen de abstracción del hardware.

Por otro lado, se están portando cada vez más lenguajes de programación a las plataformas de Sistemas Embebidos, que antes se reservaban para las computadoras de propósito general. Esto se debe a que las nuevas plataformas poseen cada vez más poder de procesamiento y memoria, a causa de la complejidad creciente de las aplicaciones deseadas. En consecuencia se utilizan lenguajes de programación más modernos, en parte por su mayor capacidad de abstacción, y en parte para estandarizar el lenguaje de programación de una aplicación en la que intervienen sistemas embebidos y computadoras de propósito general, siendo un ejemplo típico una aplicación de IoT\footnote{Del inglés \emph{Internet of Things}, es decir, Internet de las cosas, donde intervienen en una aplicación sistemas embebidos distribuídos, concentradores y servidores.}.

Existen múltiples desarrollos de bibliotecas que logran una abstracción de hardware aceptable. Sin embargo, ninguna de estas se ha adoptado como estándar de facto en la industria y el alcance de las mismas se limita a cubrir plataformas de cierto ecosistema en el marco de una empresa o comunidad y soportan un único lenguaje de programación (en general C o C++).

Este Trabajo Final intenta contribuir a la resolución de esta problemática mediante la sistematización de la implementación de bibliotecas para sistemas embebidos. Para ello se presenta el diseño de una biblioteca para la programación de sistemas embebidos modelada independientemente del lenguaje de programación y arquitectura del hardware.

También se realizaron herramientas de código abierto para desarrolladores que automatizan gran parte de la implemetación de la biblioteca en una nueva plataforma en base a na descripción de la misma, así como la definición de nuevos módulos de bibliotecas. De esta manera se facilita la futura ampliación de la biblioteca y su implementación en diferentes plataformas de hardware.		

Utilizando estas herramientas se realizó una implementación de referencia en lenguaje C para las plataformas del Proyecto CIAA []. Para su validación, se realizó un banco de pruebas de hardware, junto a la utilización de testeo unitario e integración contínua.	
